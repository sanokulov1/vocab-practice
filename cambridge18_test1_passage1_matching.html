<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Vocabulary Matching Game</title>
<style>
    /* Global reset and box-sizing */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* CSS Variables for Theming (Light Mode Defaults) */
    :root {
      /* Reverted to previous light mode colors */
      --bg-gradient: linear-gradient(135deg, #9b59b6 0%, #8e44ad 50%, #6c3483 100%);
      --container-bg: rgba(255, 255, 255, 0.95);
      --text-primary: #2d3748;
      --text-secondary: #4a5568;
      --accordion-bg: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
      --accordion-hover: linear-gradient(135deg, #0d9488 0%, #0f766e 100%);
      --card-bg: white;
      --card-border: #e2e8f0;
      --drop-zone-bg: linear-gradient(135deg, #e2e8f0 0%, #cbd5e0 100%);
      --drop-zone-border: #a0aec0;
      --button-bg: #3498db;
      --button-hover: #2980b9;
      --button-text: white;
      --correct-color: #28b463;
      --incorrect-color: #e74c3c;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      --inner-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
      --highlight-color: #f7fafc;
      --modal-bg: rgba(255, 255, 255, 0.98);
      --modal-backdrop: rgba(0, 0, 0, 0.6);
    }

    /* Dark Mode Variables */
    body.dark-mode {
      --bg-gradient: linear-gradient(135deg, #1f2937 0%, #111827 50%, #0c121e 100%);
      --container-bg: rgba(31, 41, 55, 0.95);
      --text-primary: #e2e8f0;
      --text-secondary: #a0aec0;
      --accordion-bg: linear-gradient(135deg, #0f766e 0%, #0d9488 100%);
      --accordion-hover: linear-gradient(135deg, #0d9488 0%, #0c4b46 100%);
      --card-bg: #2d3748;
      --card-border: #4a5568;
      --drop-zone-bg: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
      --drop-zone-border: #636b77;
      --button-bg: #63b3ed;
      --button-hover: #4299e1;
      --button-text: #1a202c;
      --correct-color: #48bb78;
      --incorrect-color: #fc8181;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      --inner-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      --highlight-color: #2d3748;
      --modal-bg: #1a202c;
      --modal-backdrop: rgba(0, 0, 0, 0.8);
    }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-gradient);
      display: flex;
      flex-direction: column; /* Changed to column to stack elements */
      align-items: center;
      min-height: 100vh;
      color: var(--text-primary);
      transition: background 0.3s ease, color 0.3s ease;
      padding: 20px; /* Add padding to body */
    }

    .container {
      background: var(--container-bg);
      padding: 30px;
      border-radius: 15px;
      box-shadow: var(--shadow);
      text-align: center;
      max-width: 900px;
      width: 100%;
      margin-top: 80px; /* Adjust for fixed elements like diamond count */
      margin-bottom: 40px; /* Space for navigation */
    }

    h1 {
      color: var(--text-primary);
      margin-bottom: 25px;
      font-size: 2.5em;
      font-weight: 700;
    }

    .game-area {
      display: flex;
      justify-content: space-around;
      align-items: flex-start;
      gap: 30px;
      margin-top: 30px;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .words-container, .definitions-container {
      flex: 1;
      min-width: 300px;
      max-width: 45%;
      display: flex;
      flex-direction: column;
      gap: 15px;
      background: var(--drop-zone-bg);
      padding: 20px;
      border-radius: 12px;
      border: 2px dashed var(--drop-zone-border);
    }

    .word-card, .definition-card {
      background: var(--card-bg);
      padding: 15px;
      border-radius: 8px;
      box-shadow: var(--shadow);
      cursor: grab;
      border: 1px solid var(--card-border);
      transition: all 0.2s ease;
      font-weight: 600;
      color: var(--text-primary);
      min-height: 60px; /* Ensure cards have minimum height */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .word-card.dragging {
      opacity: 0.5;
      border: 2px dashed var(--button-bg);
    }

    .definition-card.drag-over {
      box-shadow: 0 0 0 3px var(--button-bg);
    }

    .feedback {
      margin-top: 20px;
      font-size: 1.1em;
      font-weight: bold;
      min-height: 25px;
    }

    .feedback.correct {
      color: var(--correct-color);
    }

    .feedback.incorrect {
      color: var(--incorrect-color);
    }

    button#checkMatch {
      background: var(--button-bg);
      color: var(--button-text);
      border: none;
      padding: 15px 30px;
      border-radius: 10px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      margin-top: 30px;
      transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
      box-shadow: var(--shadow);
    }

    button#checkMatch:hover {
      background: var(--button-hover);
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
    }

    button#checkMatch:active {
      transform: translateY(0);
    }

    .instructions {
      margin-bottom: 20px;
      font-size: 1.1em;
      line-height: 1.6;
      color: var(--text-secondary);
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: var(--modal-backdrop);
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: var(--modal-bg);
      padding: 40px;
      border-radius: 15px;
      text-align: center;
      box-shadow: var(--shadow);
      max-width: 500px;
      width: 90%;
      color: var(--text-primary);
    }

    .modal-content h2 {
      font-size: 2.2em;
      margin-bottom: 20px;
      color: var(--correct-color); /* Use correct color for success */
    }

    .modal-content p {
      font-size: 1.1em;
      margin-bottom: 30px;
      line-height: 1.6;
    }

    .modal-content button {
      background: var(--button-bg);
      color: var(--button-text);
      border: none;
      padding: 12px 25px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .modal-content button:hover {
      background: var(--button-hover);
    }

    /* Toggle Switch Styles */
    .theme-switch-wrapper {
        position: fixed;
        top: 20px;
        right: 20px;
        display: flex;
        align-items: center;
        z-index: 10001; /* Above everything else */
    }

    .theme-switch {
        display: inline-block;
        height: 34px;
        position: relative;
        width: 60px;
    }

    .theme-switch input {
        display: none;
    }

    .slider {
        background-color: #ccc;
        bottom: 0;
        cursor: pointer;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
        transition: .4s;
    }

    .slider:before {
        background-color: #fff;
        bottom: 4px;
        content: "";
        height: 26px;
        left: 4px;
        position: absolute;
        transition: .4s;
        width: 26px;
    }

    input:checked + .slider {
        background-color: #66bb6a;
    }

    input:checked + .slider:before {
        transform: translateX(26px);
    }

    .slider.round {
        border-radius: 34px;
    }

    .slider.round:before {
        border-radius: 50%;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        .game-area {
            flex-direction: column;
            align-items: center;
        }
        .words-container, .definitions-container {
            max-width: 90%;
        }
        h1 {
            font-size: 2em;
        }
        .container {
            padding: 20px;
        }
    }
</style>
</head>
<body>

<!-- Theme Switch -->
<div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
        <input type="checkbox" id="checkbox" />
        <div class="slider round"></div>
    </label>
</div>

<div class="container">
    <h1>Vocabulary Matching Game</h1>
    <p class="instructions">Drag each vocabulary word to its correct definition.</p>
    <div class="game-area">
        <div class="words-container" id="wordsContainer">
            <!-- Words will be dynamically loaded here -->
        </div>
        <div class="definitions-container" id="definitionsContainer">
            <!-- Definitions will be dynamically loaded here -->
        </div>
    </div>
    <p id="feedback" class="feedback"></p>
    <button id="checkMatch">Check Matches</button>
</div>

<!-- Diamond Count Display (Top-Left) - Added for consistency -->
<div id="diamond-count-container">
    <span id="diamond-count">0 ðŸ’Ž</span>
</div>

<style>
#diamond-count-container {
    position: fixed;
    top: 20px;
    left: 20px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 15px;
    border-radius: 8px;
    font-family: 'Inter', sans-serif;
    font-size: 1.2em;
    font-weight: bold;
    z-index: 9999; /* Ensure it's above most content but below popup */
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    display: flex; /* Use flexbox for better alignment */
    align-items: center;
    gap: 5px; /* Space between number and diamond emoji */
}

body.dark-mode #diamond-count-container {
    background-color: rgba(255, 255, 255, 0.2);
    color: #E2E8F0;
    border: 1px solid rgba(255, 255, 255, 0.3);
}
</style>

<!-- Diamond Popup Styles & HTML (User's provided, with minor animation enhancement) -->
<style>
  #diamond-popup {
    position: fixed;
    bottom: 30px; /* Changed to bottom-right as per user's previous preference */
    right: 30px;
    background: gold;
    color: black;
    font-weight: bold;
    font-size: 24px;
    padding: 15px 25px;
    border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    display: none;
    z-index: 9999;
    /* Basic animation for fade in/out */
    opacity: 0;
    transform: translateY(0); /* Initial state for animation */
    transition: transform 1s ease-out, opacity 1s ease-out;
  }
  #diamond-popup.show {
    opacity: 1;
    transform: translateY(-80px); /* Move up for animation */
  }
</style>
<div id="diamond-popup">+1 ðŸ’Ž</div>

<!-- Navigation Buttons -->
<div class="activity-nav">
    <div class="nav-buttons">
        <a href="cambridge18_test1_passage1_quiz.html" class="nav-button next-button">Next Activity â†’</a>
    </div>
    <div class="progress-indicator">
        <div class="progress-step matching-step">Matching</div>
        <div class="progress-step quiz-step">Quiz</div>
        <div class="progress-step typing-step">Typing</div>
    </div>
</div>

<style>
/* Unified Navigation Styles */
.activity-nav {
    max-width: 800px;
    margin: 40px auto 20px;
    padding: 0 20px;
}

.nav-buttons {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 25px;
}

.nav-button {
    padding: 14px 30px;
    border: none;
    border-radius: 10px;
    font-size: 1.15em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-block;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.prev-button {
    background: #3498DB;
    color: white;
}

.next-button {
    background: #28B463;
    color: white;
}

.nav-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
}

.nav-button:active {
    transform: translateY(0);
}

.progress-indicator {
    display: flex;
    justify-content: space-between;
    position: relative;
    margin-top: 10px;
}

.progress-indicator::before {
    content: '';
    position: absolute;
    top: 20px;
    left: 0;
    right: 0;
    height: 4px;
    background: #E2E8F0;
    z-index: 1;
}

.progress-step {
    position: relative;
    z-index: 2;
    text-align: center;
    width: 33.33%;
    font-weight: 600;
    color: #A0AEC0;
}

.progress-step::before {
    content: '';
    width: 24px;
    height: 24px;
    background: #E2E8F0;
    border-radius: 50%;
    display: block;
    margin: 0 auto 10px;
    border: 4px solid white;
    box-shadow: 0 0 0 2px #E2E8F0;
}
.matching-step {
    color: #2D3748;
}
.matching-step::before {
    background: #3498DB;
    box-shadow: 0 0 0 2px #3498DB;
}
/* Dark mode adjustments */
body.dark-mode .progress-indicator::before {
    background: #4A5568;
}

body.dark-mode .progress-step::before {
    background: #4A5568;
    border-color: #1F2937;
    box-shadow: 0 0 0 2px #4A5568;
}

body.dark-mode .progress-step {
    color: #A0AEC0;
}

body.dark-mode .progress-step.matching-step::before,
body.dark-mode .progress-step.quiz-step::before,
body.dark-mode .progress-step.typing-step::before {
    background: #63B3ED;
    box-shadow: 0 0 0 2px #63B3ED;
}

body.dark-mode .matching-step,
body.dark-mode .quiz-step,
body.dark-mode .typing-step {
    color: #E2E8F0;
}
</style>

<script>
    // Theme toggle logic
    const toggleSwitch = document.getElementById('checkbox');
    const currentTheme = localStorage.getItem('theme');

    if (currentTheme) {
        document.body.classList.add(currentTheme);
        if (currentTheme === 'dark-mode') {
            toggleSwitch.checked = true;
        }
    }

    function switchTheme(e) {
        if (e.target.checked) {
            document.body.classList.add('dark-mode');
            localStorage.setItem('theme', 'dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
            localStorage.setItem('theme', 'light-mode');
        }
    }
    toggleSwitch.addEventListener('change', switchTheme);


    const words = [
        { word: "Big", definition: "Large in size." },
        { word: "Small", definition: "Little in size." },
        { word: "Happy", definition: "Feeling or showing pleasure." },
        { word: "Sad", definition: "Feeling or showing sorrow." },
        { word: "Fast", definition: "Moving or capable of moving at high speed." }
    ];

    let currentMatches = {}; // Stores {wordId: definitionId}
    let matchedCount = 0;
    const feedbackElement = document.getElementById('feedback');
    const wordsContainer = document.getElementById('wordsContainer');
    const definitionsContainer = document.getElementById('definitionsContainer');
    const checkMatchButton = document.getElementById('checkMatch');
    const completionModal = document.getElementById('completionModal');

    // Shuffle arrays
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    let shuffledWords = shuffleArray([...words]);
    let shuffledDefinitions = shuffleArray([...words]); // Shuffle definitions separately

    function renderCards() {
        wordsContainer.innerHTML = '';
        definitionsContainer.innerHTML = '';
        currentMatches = {}; // Reset matches

        shuffledWords.forEach((item, index) => {
            const wordCard = document.createElement('div');
            wordCard.classList.add('word-card');
            wordCard.textContent = item.word;
            wordCard.draggable = true;
            wordCard.dataset.wordId = item.word; // Use word itself as ID
            wordCard.addEventListener('dragstart', dragStart);
            wordsContainer.appendChild(wordCard);
        });

        shuffledDefinitions.forEach((item, index) => {
            const definitionCard = document.createElement('div');
            definitionCard.classList.add('definition-card');
            definitionCard.textContent = item.definition;
            definitionCard.dataset.definitionId = item.definition; // Use definition itself as ID
            definitionCard.addEventListener('dragover', dragOver);
            definitionCard.addEventListener('dragleave', dragLeave);
            definitionCard.addEventListener('drop', drop);
            definitionsContainer.appendChild(definitionCard);
        });
        feedbackElement.textContent = '';
        checkMatchButton.style.display = 'none'; // Hide button until all matched
        matchedCount = 0;
    }

    let draggedWordCard = null;

    function dragStart(e) {
        draggedWordCard = e.target;
        e.dataTransfer.setData('text/plain', draggedWordCard.dataset.wordId);
        setTimeout(() => {
            draggedWordCard.classList.add('dragging');
        }, 0);
    }

    function dragOver(e) {
        e.preventDefault(); // Necessary to allow drop
        e.target.classList.add('drag-over');
    }

    function dragLeave(e) {
        e.target.classList.remove('drag-over');
    }

    function drop(e) {
        e.preventDefault();
        e.target.classList.remove('drag-over');
        draggedWordCard.classList.remove('dragging');

        const wordId = e.dataTransfer.getData('text/plain');
        const definitionCard = e.target;
        const definitionId = definitionCard.dataset.definitionId;

        // Check if the definition card already has a word associated
        const existingWordCard = definitionCard.querySelector('.word-card');
        if (existingWordCard) {
            // If it does, return the existing word card to its original container
            wordsContainer.appendChild(existingWordCard);
            // Remove the old match from currentMatches
            for (const key in currentMatches) {
                if (currentMatches[key] === definitionId) {
                    delete currentMatches[key];
                    matchedCount--; // Decrement matched count as a match is broken
                    break;
                }
            }
        }

        // Check if the word card was previously matched to a different definition
        for (const key in currentMatches) {
            if (key === wordId) {
                // If so, remove the old match
                delete currentMatches[key];
                matchedCount--; // Decrement matched count as a match is broken
                break;
            }
        }

        // Append the dragged word card to the definition card
        definitionCard.appendChild(draggedWordCard);
        currentMatches[wordId] = definitionId; // Store the new match
        matchedCount++; // Increment matched count for the new match

        // Show check button if all words are placed
        if (matchedCount === words.length) {
            checkMatchButton.style.display = 'block';
        } else {
            checkMatchButton.style.display = 'none';
        }

        feedbackElement.textContent = ''; // Clear feedback on new drops
    }

    checkMatchButton.addEventListener('click', () => {
        let allCorrect = true;
        let correctCount = 0;

        // Iterate through the original words array to check against currentMatches
        words.forEach(wordObj => {
            const correctDefinition = wordObj.definition;
            const currentMatchedDefinition = currentMatches[wordObj.word];

            // Check if a word was matched and if the match is correct
            if (currentMatchedDefinition && currentMatchedDefinition === correctDefinition) {
                correctCount++;
            } else {
                allCorrect = false;
            }
        });

        if (allCorrect) {
            feedbackElement.textContent = 'All matches are correct! Well done!';
            feedbackElement.classList.remove('incorrect');
            feedbackElement.classList.add('correct');
            checkMatchButton.style.display = 'none'; // Hide button after success
            showCompletionModal();
            onMatchingComplete(); // Trigger diamond update
        } else {
            feedbackElement.textContent = 'Some matches are incorrect. Try again!';
            feedbackElement.classList.remove('correct');
            feedbackElement.classList.add('incorrect');
        }
    });

    function showCompletionModal() {
        const modal = document.createElement('div');
        modal.classList.add('modal');
        modal.innerHTML = `
            <div class="modal-content">
                <h2>Congratulations!</h2>
                <p>You have successfully matched all the vocabulary words to their definitions.</p>
                <button onclick="closeCompletionModal()">Continue</button>
            </div>
        `;
        document.body.appendChild(modal);
        modal.style.display = 'flex'; // Make it visible
    }

    function closeCompletionModal() {
        const modal = document.querySelector('.modal');
        if (modal) {
            modal.remove(); // Remove modal from DOM
        }
        renderCards(); // Reset the game
    }

    // Initial render
    renderCards();

</script>

<!-- Firebase SDKs and Initialization (Modular API) -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    // FIX: Added setDoc to the import list
    import { getFirestore, doc, setDoc, increment, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    // Firebase Configuration (from user)
    const firebaseConfig = {
        apiKey: "AIzaSyChct6kCeqDlgbAuAJw3wP_tHOYN6gV-n4",
        authDomain: "website-vocabulary.firebaseapp.com",
        projectId: "website-vocabulary",
        storageBucket: "website-vocabulary.firebasestorage.app",
        messagingSenderId: "216286165163",
        appId: "1:216286165163:web:0d45648c2b998070a11fee",
        measurementId: "G-1RZLN9HJ65"
    };

    // Initialize Firebase App
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // Expose auth and db globally for existing activity scripts to use
    window.auth = auth;
    window.db = db;

    // Handle authentication for Canvas environment or anonymous sign-in
    async function authenticateUser() {
        try {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
                console.log("Authenticated with custom token.");
            } else {
                await signInAnonymously(auth);
                console.log("Signed in anonymously.");
            }
        } catch (error) {
            console.error("Firebase authentication error:", error);
        }
    }

    // Call authentication when the script loads
    authenticateUser();

    // Function to update diamond count display (top-left)
    async function updateDiamondCountDisplay() {
        const diamondCountElement = document.getElementById('diamond-count');
        if (!diamondCountElement) return;

        const user = auth.currentUser;
        if (user) {
            const userRef = doc(db, "users", user.uid);
            try {
                const docSnap = await getDoc(userRef);
                if (docSnap.exists()) {
                    const diamonds = docSnap.data().diamonds || 0;
                    diamondCountElement.textContent = `${diamonds} ðŸ’Ž`;
                } else {
                    // If user document doesn't exist, initialize diamonds to 0
                    await setDoc(userRef, { diamonds: 0 }, { merge: true });
                    diamondCountElement.textContent = '0 ï¿½';
                }
            } catch (error) {
                console.error("Error fetching or initializing diamond count:", error);
                diamondCountElement.textContent = 'Error ðŸ’Ž';
            }
        } else {
            diamondCountElement.textContent = '0 ðŸ’Ž'; // Or a login prompt for logged-out users
        }
    }

    // Listen for auth state changes to update diamond count display
    onAuthStateChanged(auth, (user) => {
        updateDiamondCountDisplay();
    });

    // Diamond Popup Function (moved here to use Firebase's increment)
    function showDiamondPopup(amount) {
        const popup = document.getElementById("diamond-popup");
        if (!popup) return;

        // Format amount to show at most one decimal place
        const formattedAmount = amount % 1 === 0 ? amount.toString() : amount.toFixed(1);
        popup.textContent = `+${formattedAmount} Diamond${amount !== 1 ? 's' : ''}!`;

        // Trigger reflow to restart animation:
        popup.classList.remove('show');
        void popup.offsetWidth; // This line forces a reflow
        popup.classList.add('show');

        // Hide after animation
        setTimeout(() => {
            popup.classList.remove('show');
            popup.style.display = 'none'; // Hide fully after transition
        }, 1500); // Total display time (animation duration + slight delay)
        popup.style.display = 'block'; // Ensure it's visible to start animation
    }

    // Function to update user's diamond count in Firestore
    window.updateDiamondCount = async function(diamondsEarned) {
        const user = auth.currentUser;
        if (!user) {
            console.log("No user logged in to record diamond update.");
            return;
        }

        const userRef = doc(db, "users", user.uid);
        try {
            // THIS IS THE CRITICAL CHANGE: Use setDoc with merge: true
            await setDoc(userRef, {
                diamonds: increment(diamondsEarned)
            }, { merge: true }); // <--- Changed from updateDoc to setDoc with merge
            console.log(`Diamonds updated: +${diamondsEarned}`);
            showDiamondPopup(diamondsEarned);
            updateDiamondCountDisplay(); // Update top-left display immediately
        } catch (error) {
            console.error("Error updating document for diamonds:", error);
        }
    };

    // Activity completion hooks (now call window.updateDiamondCount)
    window.onMatchingComplete = function() {
        // In matching, they should get 1 diamond if they complete all the groups
        // The game logic already ensures allCorrect before calling this.
        window.updateDiamondCount(1);
    };

    // No onQuizComplete or onTypingComplete here, they belong in their respective files.

    // Initial update of diamond count display on page load
    onAuthStateChanged(auth, (user) => {
        if (user) {
            updateDiamondCountDisplay();
        }
    });

</script>

</body>
</html>
ï¿½
