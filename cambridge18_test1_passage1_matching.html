<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Vocabulary Matching Game</title>
<style>
    /* Global reset and box-sizing */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* CSS Variables for Theming (Light Mode Defaults) */
    :root {
      /* Reverted to previous light mode colors */
      --bg-gradient: linear-gradient(135deg, #9b59b6 0%, #8e44ad 50%, #6c3483 100%);
      --container-bg: rgba(255, 255, 255, 0.95);
      --text-primary: #2d3748;
      --text-secondary: #4a5568;
      --accordion-bg: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
      --accordion-hover: linear-gradient(135deg, #0d9488 0%, #0f766e 100%);
      --card-bg: white;
      --card-border: #e2e8f0;
      --drop-zone-bg: linear-gradient(135deg, #e2e8f0 0%, #cbd5e0 100%);
      --drop-zone-border: #a0aec0;
      --button-bg: #3498db;
      --button-hover: #2980b9;
      --button-text: white;
      --correct-color: #28b463;
      --incorrect-color: #e74c3c;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      --inner-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
      --highlight-color: #f7fafc;
      --modal-bg: rgba(255, 255, 255, 0.98);
      --modal-backdrop: rgba(0, 0, 0, 0.6);
    }

    /* Dark Mode Variables */
    body.dark-mode {
      --bg-gradient: linear-gradient(135deg, #1f2937 0%, #111827 50%, #0c121e 100%);
      --container-bg: rgba(31, 41, 55, 0.95);
      --text-primary: #e2e8f0;
      --text-secondary: #a0aec0;
      --accordion-bg: linear-gradient(135deg, #0f766e 0%, #0d9488 100%);
      --accordion-hover: linear-gradient(135deg, #0d9488 0%, #0c4b46 100%);
      --card-bg: #2d3748;
      --card-border: #4a5568;
      --drop-zone-bg: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
      --drop-zone-border: #636b77;
      --button-bg: #63b3ed;
      --button-hover: #4299e1;
      --button-text: #1a202c;
      --correct-color: #48bb78;
      --incorrect-color: #fc8181;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      --inner-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      --highlight-color: #2d3748;
      --modal-bg: #1a202c;
      --modal-backdrop: rgba(0, 0, 0, 0.8);
    }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-gradient);
      display: flex;
      flex-direction: column; /* Changed to column to stack elements */
      align-items: center;
      min-height: 100vh;
      color: var(--text-primary);
      transition: background 0.3s ease, color 0.3s ease;
      padding: 20px; /* Add padding to body */
    }

    .container {
      background: var(--container-bg);
      padding: 30px;
      border-radius: 15px;
      box-shadow: var(--shadow);
      text-align: center;
      max-width: 900px;
      width: 100%;
      margin-top: 80px; /* Adjust for fixed elements like diamond count */
      margin-bottom: 40px; /* Space for navigation */
    }

    h1 {
      color: var(--text-primary);
      margin-bottom: 25px;
      font-size: 2.5em;
      font-weight: 700;
    }

    .game-area {
      display: flex;
      justify-content: space-around;
      align-items: flex-start;
      gap: 30px;
      margin-top: 30px;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .words-container, .definitions-container {
      flex: 1;
      min-width: 300px;
      max-width: 45%;
      display: flex;
      flex-direction: column;
      gap: 15px;
      background: var(--drop-zone-bg);
      padding: 20px;
      border-radius: 12px;
      border: 2px dashed var(--drop-zone-border);
    }

    .word-card, .definition-card {
      background: var(--card-bg);
      padding: 15px;
      border-radius: 8px;
      box-shadow: var(--shadow);
      cursor: grab;
      border: 1px solid var(--card-border);
      transition: all 0.2s ease;
      font-weight: 600;
      color: var(--text-primary);
      min-height: 60px; /* Ensure cards have minimum height */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .word-card.dragging {
      opacity: 0.5;
      border: 2px dashed var(--button-bg);
    }

    .definition-card.drag-over {
      box-shadow: 0 0 0 3px var(--button-bg);
    }

    .feedback {
      margin-top: 20px;
      font-size: 1.1em;
      font-weight: bold;
      min-height: 25px;
    }

    .feedback.correct {
      color: var(--correct-color);
    }

    .feedback.incorrect {
      color: var(--incorrect-color);
    }

    button#checkMatch {
      background: var(--button-bg);
      color: var(--button-text);
      border: none;
      padding: 15px 30px;
      border-radius: 10px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      margin-top: 30px;
      transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
      box-shadow: var(--shadow);
    }

    button#checkMatch:hover {
      background: var(--button-hover);
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
    }

    button#checkMatch:active {
      transform: translateY(0);
    }

    .instructions {
      margin-bottom: 20px;
      font-size: 1.1em;
      line-height: 1.6;
      color: var(--text-secondary);
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: var(--modal-backdrop);
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: var(--modal-bg);
      padding: 40px;
      border-radius: 15px;
      text-align: center;
      box-shadow: var(--shadow);
      max-width: 500px;
      width: 90%;
      color: var(--text-primary);
    }

    .modal-content h2 {
      font-size: 2.2em;
      margin-bottom: 20px;
      color: var(--correct-color); /* Use correct color for success */
    }

    .modal-content p {
      font-size: 1.1em;
      margin-bottom: 30px;
      line-height: 1.6;
    }

    .modal-content button {
      background: var(--button-bg);
      color: var(--button-text);
      border: none;
      padding: 12px 25px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .modal-content button:hover {
      background: var(--button-hover);
    }

    /* Toggle Switch Styles */
    .theme-switch-wrapper {
        position: fixed;
        top: 20px;
        right: 20px;
        display: flex;
        align-items: center;
        z-index: 10001; /* Above everything else */
    }

    .theme-switch {
        display: inline-block;
        height: 34px;
        position: relative;
        width: 60px;
    }

    .theme-switch input {
        display: none;
    }

    .slider {
        background-color: #ccc;
        bottom: 0;
        cursor: pointer;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
        transition: .4s;
    }

    .slider:before {
        background-color: #fff;
        bottom: 4px;
        content: "";
        height: 26px;
        left: 4px;
        position: absolute;
        transition: .4s;
        width: 26px;
    }

    input:checked + .slider {
        background-color: #66bb6a;
    }

    input:checked + .slider:before {
        transform: translateX(26px);
    }

    .slider.round {
        border-radius: 34px;
    }

    .slider.round:before {
        border-radius: 50%;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        .game-area {
            flex-direction: column;
            align-items: center;
        }
        .words-container, .definitions-container {
            max-width: 90%;
        }
        h1 {
            font-size: 2em;
        }
        .container {
            padding: 20px;
        }
    }
</style>
</head>
<body>

<div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
        <input type="checkbox" id="checkbox" />
        <div class="slider round"></div>
    </label>
</div>

<div class="container">
    <h1>Vocabulary Matching Game</h1>
    <p class="instructions">Drag each vocabulary word to its correct definition.</p>
    <div class="game-area">
        <div class="words-container" id="wordsContainer">
            </div>
        <div class="definitions-container" id="definitionsContainer">
            </div>
    </div>
    <p id="feedback" class="feedback"></p>
    <button id="checkMatch">Check Matches</button>
</div>

<div id="diamond-count-container">
    <span id="diamond-count">0 ðŸ’Ž</span>
</div>

<style>
#diamond-count-container {
    position: fixed;
    top: 20px;
    left: 20px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 15px;
    border-radius: 8px;
    font-family: 'Inter', sans-serif;
    font-size: 1.2em;
    font-weight: bold;
    z-index: 9999; /* Ensure it's above most content but below popup */
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    display: flex; /* Use flexbox for better alignment */
    align-items: center;
    gap: 5px; /* Space between number and diamond emoji */
}

body.dark-mode #diamond-count-container {
    background-color: rgba(255, 255, 255, 0.2);
    color: #E2E8F0;
    border: 1px solid rgba(255, 255, 255, 0.3);
}
</style>

<style>
  #diamond-popup {
    position: fixed;
    top: 30%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: gold;
    color: black;
    font-weight: bold;
    font-size: 24px;
    padding: 15px 25px;
    border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    display: none;
    z-index: 9999;
    /* Basic animation for fade in/out */
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
  }
  #diamond-popup.show {
    opacity: 1;
  }
</style>
<div id="diamond-popup">+1 ðŸ’Ž</div>

<div class="activity-nav">
    <div class="nav-buttons">
        <a href="cambridge18_test1_passage1_quiz.html" class="nav-button next-button">Next Activity â†’</a>
    </div>
    <div class="progress-indicator">
        <div class="progress-step matching-step">Matching</div>
        <div class="progress-step quiz-step">Quiz</div>
        <div class="progress-step typing-step">Typing</div>
    </div>
</div>

<style>
/* Unified Navigation Styles */
.activity-nav {
    max-width: 800px;
    margin: 40px auto 20px;
    padding: 0 20px;
}

.nav-buttons {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 25px;
}

.nav-button {
    padding: 14px 30px;
    border: none;
    border-radius: 10px;
    font-size: 1.15em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-block;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.prev-button {
    background: #3498DB;
    color: white;
}

.next-button {
    background: #28B463;
    color: white;
}

.nav-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
}

.nav-button:active {
    transform: translateY(0);
}

.progress-indicator {
    display: flex;
    justify-content: space-between;
    position: relative;
    margin-top: 10px;
}

.progress-indicator::before {
    content: '';
    position: absolute;
    top: 20px;
    left: 0;
    right: 0;
    height: 4px;
    background: #E2E8F0;
    z-index: 1;
}

.progress-step {
    position: relative;
    z-index: 2;
    text-align: center;
    width: 33.33%;
    font-weight: 600;
    color: #A0AEC0;
}

.progress-step::before {
    content: '';
    width: 24px;
    height: 24px;
    background: #E2E8F0;
    border-radius: 50%;
    display: block;
    margin: 0 auto 10px;
    border: 4px solid white;
    box-shadow: 0 0 0 2px #E2E8F0;
}
.matching-step {
    color: #2D3748;
}
.matching-step::before {
    background: #3498DB;
    box-shadow: 0 0 0 2px #3498DB;
}
/* Dark mode adjustments */
body.dark-mode .progress-indicator::before {
    background: #4A5568;
}

body.dark-mode .progress-step::before {
    background: #4A5568;
    border-color: #1F2937;
    box-shadow: 0 0 0 2px #4A5568;
}

body.dark-mode .progress-step {
    color: #A0AEC0;
}

body.dark-mode .progress-step.matching-step::before,
body.dark-mode .progress-step.quiz-step::before,
body.dark-mode .progress-step.typing-step::before {
    background: #63B3ED;
    box-shadow: 0 0 0 2px #63B3ED;
}

body.dark-mode .matching-step,
body.dark-mode .quiz-step,
body.dark-mode .typing-step {
    color: #E2E8F0;
}
</style>

<script>
    // Theme toggle logic
    const toggleSwitch = document.getElementById('checkbox');
    const currentTheme = localStorage.getItem('theme');

    if (currentTheme) {
        document.body.classList.add(currentTheme);
        if (currentTheme === 'dark-mode') {
            toggleSwitch.checked = true;
        }
    }

    function switchTheme(e) {
        if (e.target.checked) {
            document.body.classList.add('dark-mode');
            localStorage.setItem('theme', 'dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
            localStorage.setItem('theme', 'light-mode');
        }
    }
    toggleSwitch.addEventListener('change', switchTheme);


    const words = [
        { word: "Serendipity", definition: "The occurrence and development of events by chance in a happy or beneficial way." },
        { word: "Ephemeral", definition: "Lasting for a very short time." },
        { word: "Luminous", definition: "Emitting or reflecting light; shining." },
        { word: "Mellifluous", definition: "Pleasant to hear." },
        { word: "Sycophant", definition: "A person who acts obsequiously toward someone important in order to gain advantage." }
    ];

    let currentMatches = {}; // Stores {wordId: definitionId}
    let matchedCount = 0;
    const feedbackElement = document.getElementById('feedback');
    const wordsContainer = document.getElementById('wordsContainer');
    const definitionsContainer = document.getElementById('definitionsContainer');
    const checkMatchButton = document.getElementById('checkMatch');
    const completionModal = document.getElementById('completionModal');

    // Shuffle arrays
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    let shuffledWords = shuffleArray([...words]);
    let shuffledDefinitions = shuffleArray([...words]); // Shuffle definitions separately

    function renderCards() {
        wordsContainer.innerHTML = '';
        definitionsContainer.innerHTML = '';
        currentMatches = {}; // Reset matches

        shuffledWords.forEach((item, index) => {
            const wordCard = document.createElement('div');
            wordCard.classList.add('word-card');
            wordCard.textContent = item.word;
            wordCard.draggable = true;
            wordCard.dataset.wordId = item.word; // Use word itself as ID
            wordCard.addEventListener('dragstart', dragStart);
            wordsContainer.appendChild(wordCard);
        });

        shuffledDefinitions.forEach((item, index) => {
            const definitionCard = document.createElement('div');
            definitionCard.classList.add('definition-card');
            definitionCard.textContent = item.definition;
            definitionCard.dataset.definitionId = item.definition; // Use definition itself as ID
            definitionCard.addEventListener('dragover', dragOver);
            definitionCard.addEventListener('dragleave', dragLeave);
            definitionCard.addEventListener('drop', drop);
            definitionsContainer.appendChild(definitionCard);
        });
        feedbackElement.textContent = '';
        checkMatchButton.style.display = 'none'; // Hide button until all matched
        matchedCount = 0;
    }

    let draggedWordCard = null;

    function dragStart(e) {
        draggedWordCard = e.target;
        e.dataTransfer.setData('text/plain', draggedWordCard.dataset.wordId);
        setTimeout(() => {
            draggedWordCard.classList.add('dragging');
        }, 0);
    }

    function dragOver(e) {
        e.preventDefault(); // Necessary to allow drop
        e.target.classList.add('drag-over');
    }

    function dragLeave(e) {
        e.target.classList.remove('drag-over');
    }

    function drop(e) {
        e.preventDefault();
        e.target.classList.remove('drag-over');
        draggedWordCard.classList.remove('dragging');

        const wordId = e.dataTransfer.getData('text/plain');
        const definitionCard = e.target;
        const definitionId = definitionCard.dataset.definitionId;

        // Check if the definition card already has a word associated
        const existingWordCard = definitionCard.querySelector('.word-card');
        if (existingWordCard) {
            // If it does, return the existing word card to its original container
            wordsContainer.appendChild(existingWordCard);
            // Remove the old match from currentMatches
            for (const key in currentMatches) {
                if (currentMatches[key] === definitionId) {
                    delete currentMatches[key];
                    matchedCount--; // Decrement matched count as a match is broken
                    break;
                }
            }
        }

        // Check if the word card was previously matched to a different definition
        for (const key in currentMatches) {
            if (key === wordId) {
                // If so, remove the old match
                delete currentMatches[key];
                matchedCount--; // Decrement matched count as a match is broken
                break;
            }
        }

        // Append the dragged word card to the definition card
        definitionCard.appendChild(draggedWordCard);
        currentMatches[wordId] = definitionId; // Store the new match
        matchedCount++; // Increment matched count for the new match

        // Show check button if all words are placed
        if (matchedCount === words.length) {
            checkMatchButton.style.display = 'block';
        } else {
            checkMatchButton.style.display = 'none';
        }

        feedbackElement.textContent = ''; // Clear feedback on new drops
    }

    checkMatchButton.addEventListener('click', () => {
        let allCorrect = true;
        let correctCount = 0;

        // Iterate through the original words array to check against currentMatches
        words.forEach(wordObj => {
            const correctDefinition = wordObj.definition;
            const currentMatchedDefinition = currentMatches[wordObj.word];

            // Check if a word was matched and if the match is correct
            if (currentMatchedDefinition && currentMatchedDefinition === correctDefinition) {
                correctCount++;
            } else {
                allCorrect = false;
            }
        });

        if (allCorrect) {
            feedbackElement.textContent = 'All matches are correct! Well done!';
            feedbackElement.classList.remove('incorrect');
            feedbackElement.classList.add('correct');
            checkMatchButton.style.display = 'none'; // Hide button after success
            showCompletionModal();
            onMatchingComplete(); // Trigger diamond update
        } else {
            feedbackElement.textContent = 'Some matches are incorrect. Try again!';
            feedbackElement.classList.remove('correct');
            feedbackElement.classList.add('incorrect');
        }
    });

    function showCompletionModal() {
        const modal = document.createElement('div');
        modal.classList.add('modal');
        modal.innerHTML = `
            <div class="modal-content">
                <h2>Congratulations!</h2>
                <p>You have successfully matched all the vocabulary words to their definitions.</p>
                <button onclick="closeCompletionModal()">Continue</button>
            </div>
        `;
        document.body.appendChild(modal);
        modal.style.display = 'flex'; // Make it visible
    }

    function closeCompletionModal() {
        const modal = document.querySelector('.modal');
        if (modal) {
            modal.remove(); // Remove modal from DOM
        }
        renderCards(); // Reset the game
    }

    // Initial render
    renderCards();

</script>

<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js"></script>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyChct6kCeqDlgbAuAJw3wP_tHOYN6gV-n4",
    authDomain: "website-vocabulary.firebaseapp.com",
    projectId: "website-vocabulary",
    storageBucket: "website-vocabulary.firebasestorage.app",
    messagingSenderId: "216286165163",
    appId: "1:216286165163:web:0d45648c2b998070a11fee",
    measurementId: "G-1RZLN9HJ65"
  };

  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();
  window.auth = auth; // Expose to global window object for console debugging
  window.db = db;     // Expose to global window object for console debugging

  let startTime = Date.now();
  window.addEventListener("beforeunload", () => {
    const timeSpent = Math.floor((Date.now() - startTime) / 1000);
    const user = auth.currentUser;
    if (user) {
      const userRef = db.collection("users").doc(user.uid);
      userRef.update({
        timeSpent: firebase.firestore.FieldValue.increment(timeSpent),
        diamonds: firebase.firestore.FieldValue.increment(Math.floor(timeSpent / 3600) * 10)
      }).catch(error => {
        console.error("Error updating time spent/diamonds on unload:", error);
      });
    }
  });

  // Function to update diamond count display (top-left)
  async function updateDiamondCountDisplay(user) {
      const diamondCountElement = document.getElementById('diamond-count');
      if (diamondCountElement) {
          if (user) {
              const userRef = db.collection("users").doc(user.uid);
              try {
                  const docSnap = await userRef.get();
                  if (docSnap.exists) {
                      const diamonds = docSnap.data().diamonds || 0;
                      diamondCountElement.textContent = `${diamonds} ðŸ’Ž`;
                  } else {
                      diamondCountElement.textContent = '0 ðŸ’Ž';
                  }
              } catch (error) {
                  console.error("Error fetching diamond count:", error);
                  diamondCountElement.textContent = 'Error ðŸ’Ž';
              }
          } else {
              diamondCountElement.textContent = '0 ðŸ’Ž';
          }
      }
  }

  // Listen for auth state changes to update diamond count and potentially other UI
  auth.onAuthStateChanged((user) => {
      updateDiamondCountDisplay(user);
  });

  function showDiamondPopup(amount = 1) {
    const popup = document.getElementById("diamond-popup");
    popup.textContent = `+${amount} ðŸ’Ž`;
    popup.classList.add('show'); // Add 'show' class to trigger animation
    setTimeout(() => {
      popup.classList.remove('show'); // Remove 'show' to fade out
      // Hide completely after fade out animation (if needed for older browsers)
      setTimeout(() => { popup.style.display = "none"; }, 500); // Match transition duration
    }, 1500); // Total display time
    popup.style.display = "block"; // Make visible to start transition
  }

  function updateDiamondCount(diamondsEarned) {
    const user = auth.currentUser;
    if (!user) return;
    const userRef = db.collection("users").doc(user.uid);

    userRef.get().then(doc => {
      const current = doc.exists && doc.data().diamonds ? doc.data().diamonds : 0;
      userRef.set({ diamonds: current + diamondsEarned }, { merge: true })
        .then(() => {
          showDiamondPopup(diamondsEarned);
          updateDiamondCountDisplay(user); // Update top-left display after earning
        })
        .catch(error => {
          console.error("Error updating diamond count:", error);
        });
    }).catch(error => {
        console.error("Error getting user document for diamond update:", error);
    });
  }

  // Example hook (call this when an activity is completed)
  function onQuizComplete(correctAnswers) {
    if (correctAnswers >= 10) {
      updateDiamondCount(1.5);
    } else if (correctAnswers >= 7) {
      updateDiamondCount(1);
    }
  }

  function onTypingComplete(correctAnswers) {
    if (correctAnswers >= 10) {
      updateDiamondCount(1.5);
    } else if (correctAnswers >= 6) {
      updateDiamondCount(1);
    }
  }

  function onMatchingComplete() {
    updateDiamondCount(1);
  }
</script>

</body>
</html>